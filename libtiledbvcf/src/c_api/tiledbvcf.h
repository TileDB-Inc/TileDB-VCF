/**
 * @file   tiledbvcf.h
 *
 * @section LICENSE
 *
 * The MIT License
 *
 * @copyright Copyright (c) 2019 TileDB, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @section DESCRIPTION
 *
 * This file declares the C API for TileDB-VCF.
 */

#ifndef TILEDB_VCF_H
#define TILEDB_VCF_H

// Generated by CMake; defines TILEDBVCF_EXPORT (etc) macros.
#include "tiledbvcf_export.h"

#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ********************************* */
/*             CONSTANTS             */
/* ********************************* */

/** Success */
#define TILEDB_VCF_OK 0
/** General error */
#define TILEDB_VCF_ERR (-1)

/* ********************************* */
/*               ENUMS               */
/* ********************************* */

/** Reader status. */
typedef enum {
/** Helper macro for defining read reader status enums. */
#define TILEDB_VCF_READ_STATUS_ENUM(id) TILEDB_VCF_##id
#include "tiledbvcf_enum.h"
#undef TILEDB_VCF_READ_STATUS_ENUM
} tiledb_vcf_read_status_t;

/** Attribute datatype. */
typedef enum {
/** Helper macro for defining attribute datatype enums. */
#define TILEDB_VCF_ATTR_DATATYPE_ENUM(id) TILEDB_VCF_##id
#include "tiledbvcf_enum.h"
#undef TILEDB_VCF_ATTR_DATATYPE_ENUM
} tiledb_vcf_attr_datatype_t;

/** Checksum filter types. */
typedef enum {
/** Helper macro for defining subset of tiledb filter type enums. */
#define TILEDB_VCF_CHECKSUM_TYPE_ENUM(id) TILEDB_VCF_##id
#include "tiledbvcf_enum.h"
#undef TILEDB_VCF_CHECKSUM_TYPE_ENUM
} tiledb_vcf_checksum_type_t;

/* ********************************* */
/*           STRUCT TYPES            */
/* ********************************* */

/** Reader object. */
typedef struct tiledb_vcf_reader_t tiledb_vcf_reader_t;

/** Writer object. */
typedef struct tiledb_vcf_writer_t tiledb_vcf_writer_t;

/** Error object. */
typedef struct tiledb_vcf_error_t tiledb_vcf_error_t;

/** Bed file object. */
typedef struct tiledb_vcf_bed_file_t tiledb_vcf_bed_file_t;

/* ********************************* */
/*              MISC                 */
/* ********************************* */

/**
 *  Retrieves the version of the TileDB VCF library currently being used.
 *
 *  @param version Will store the string representation
 */
TILEDBVCF_EXPORT void tiledb_vcf_version(const char** version);

TILEDBVCF_EXPORT void tiledb_vcf_config_logging(
    const char* level, const char* logfile);

/* ********************************* */
/*              READER               */
/* ********************************* */

/**
 * Allocates a VCF reader object.
 *
 * A VCF reader is used for reading from existing TileDB-VCF datasets. Reading
 * from a TileDB-VCF dataset is accomplished by specifying a set of sample
 * names, a set of genomic regions, and a set of "attributes" per sample to read
 * from the dataset.
 *
 * @param reader Will be set to point at the allocated reader object.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_alloc(tiledb_vcf_reader_t** reader);

/**
 * Frees the given VCF reader object, freeing any held memory or resources.
 *
 * @param reader Pointer to reader object to free.
 */
TILEDBVCF_EXPORT void tiledb_vcf_reader_free(tiledb_vcf_reader_t** reader);

/**
 * Initializes the reader for reading from the dataset at the given URI.
 *
 * @param reader VCF reader object
 * @param dataset_uri URI of TileDB VCF dataset
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_reader_init(tiledb_vcf_reader_t* reader, const char* dataset_uri);

/**
 * Sets the URI of a file containing sample names to read. The file should
 * contain, one per line, the names of samples in the dataset to be read.
 *
 * You can also manually specify sample names without a file with the
 * `tiledb_vcf_reader_set_samples()` function.
 *
 * If you specify both a CSV samples list and a samples file, samples from both
 * will be included in the read.
 *
 * @param reader VCF reader object
 * @param samples_uri URI of file containing sample names.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_samples_file(
    tiledb_vcf_reader_t* reader, const char* uri);

/**
 * Sets the URI of a BED file containing regions to be read.
 *
 * The BED file is assumed to follow the format of bcftools: a tab-separated
 * file of the format `contig   start   end` where the start/end interval
 * is a 0-indexed, half-open interval.
 *
 * You can also manually specify regions without a BED file with the
 * `tiledb_vcf_reader_set_regions()` function.
 *
 * If you specify both a CSV regions list and a BED file, regions from both
 * will be included in the read.
 *
 * @param reader VCF reader object
 * @param uri URI of BED file
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_reader_set_bed_file(tiledb_vcf_reader_t* reader, const char* uri);

/**
 * Given a CSV string of sample names, sets the samples to be read.
 *
 * If you specify both a CSV samples list and a samples file, samples from both
 * will be included in the read.
 *
 * @param reader VCF reader object
 * @param samples CSV list of sample names.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_reader_set_samples(tiledb_vcf_reader_t* reader, const char* samples);

/**
 * Given a CSV string of genomic regions, sets the regions to be read.
 *
 * Each region string should be in the form "contig:start-end". The start/end
 * interval should be a 1-indexed, inclusive interval. This is different from
 * the intervals specified in a BED file (which are 0-indexed, half-open
 * intervals).
 *
 * If you specify both a CSV regions list and a BED file, regions from both
 * will be included in the read.
 *
 * @param reader VCF reader object
 * @param ranges CSV list of region strings
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_reader_set_regions(tiledb_vcf_reader_t* reader, const char* regions);

/**
 * Sets whether or not to sort the regions to be read. By default, the regions
 * from the BED file (if specified) and the CSV regions (if specified) are
 * combined and then sorted. This can be slow if there are many regions in
 * total.
 *
 * If you are only specifying a BED file, and you are certain that the regions
 * within it are already sorted, you can disable sorting here to gain some
 * performance. The behavior is undefined if you disable sorting but the BED
 * file is not actually sorted.
 *
 * The sorting order is first on contig (in the order specified in the VCF
 * header of the ingested samples), and then on start position.
 *
 * @param reader VCF reader object
 * @param sort_regions If `1`, regions will be sorted (the default). If `0`,
 *      region sorting is disabled.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_sort_regions(
    tiledb_vcf_reader_t* reader, int32_t sort_regions);

/**
 * Sets the region partitioning info for the reader. The partitioning divides
 * the reader genomic regions (e.g. the BED ranges) according to a simple block
 * distribution.
 *
 * For example, suppose a BED file is specified that contains 1,000 regions.
 * With 10 partitions, each partition would be responsible for 100 regions of
 * the BED file. Partition index 0 would take regions [0, 99], index 1 would
 * take regions [100, 199], etc.
 *
 * You can combine region and sample partitioning.
 *
 * @param reader VCF reader object
 * @param partition Index of region partition that this reader object should
 *      process.
 * @param num_partitions Total number of region partitions.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_region_partition(
    tiledb_vcf_reader_t* reader, int32_t partition, int32_t num_partitions);

/**
 * Sets the sample partitioning info for the reader. The partitioning divides
 * the samples being read according to a simple block distribution.
 *
 * For example, suppose a samples file is specified that contains 1,000 sample
 * names. With 10 partitions, each partition would be responsible for reading
 * 100 samples. Partition index 0 would take samples [0, 99], index 1 would take
 * samples [100, 199], etc.
 *
 * You can combine region and sample partitioning.
 *
 * @param reader VCF reader object
 * @param partition Index of sample partition that this reader object should
 *      process.
 * @param num_partitions Total number of sample partitions.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_sample_partition(
    tiledb_vcf_reader_t* reader, int32_t partition, int32_t num_partitions);

/**
 * Sets a buffer to hold values for a specific attribute being read. This is the
 * main interface by which VCF data is returned from a read operation.
 *
 * The in-memory format of the returned data follows the Apache Arrow
 * specification for fixed-length, variable-length (e.g. List<char>), and list
 * variable-length (e.g. List<List<char>>)values. The values are all
 * little-endian.
 *
 * The allowed attributes and their Arrow-like datatypes are:
 *
 * - "sample_name": The sample name  (List<char>, non-nullable)
 * - "contig": The contig name of record  (List<char>, non-nullable)
 * - "pos_start": The 1-based start position of record  (int32, non-nullable)
 * - "pos_end": The 1-based end position of record  (int32, non-nullable)
 * - "query_bed_start": The 0-based start position of the query BED range that
 *    intersected the record.  (int32, non-nullable)
 * - "query_bed_end": The 1-based end position of the query BED range that
 *    intersected the record.  (int32, non-nullable)
 * - "alleles": List of allele names  (List<List<char>>, non-nullable)
 * - "id": ID string  (List<char>, non-nullable)
 * - "filters": List of filter names  (List<List<char>>, nullable)
 * - "qual": The quality value  (float32, non-nullable)
 * - "info_*": A specific INFO field value  (List<?>, nullable)
 * - "fmt_*": A specific FMT field value  (List<?>, nullable)
 * - "fmt": Format byte blob of non-attribute fields  (List<byte>, nullable)
 * - "info": Info byte blob of non-attribute fields  (List<byte>, nullable)
 *
 * See the specific notes below for more information.
 *
 * (1) Variable-length vs fixed-length
 * Fixed-length attributes, such as `pos_start` or `qual`, contain a
 * single value per result record. Variable-length attributes, such as
 * `sample_name` or `info_* / fmt_*`, contain a variable number of values per
 * result record, which may be 0.
 *
 * For variable-length attributes, such as `sample_name`, an extra "offsets"
 * buffer must be provided. This will be populated with the starting offset of
 * the variable-length value in the associated data buffer, for each record.
 *
 * For list variable length attributes, such as `alleles`, in addition to an
 * offsets buffer, a separate "list offsets" buffer must also be provided.
 *
 * The contents of the values and offset buffers follow the Apache Arrow
 * semantics.
 *
 * (2) INFO/FMT fields
 * In general to access specific INFO or FMT field values, you should
 * use the special `fmt_*` / `info_*` attribute names. For example, to
 * retrieve the values of the `MIN_DP` format field, set a buffer for
 * attribute `fmt_MIN_DP`. The generic `fmt` and `info` byte blob attributes
 * are mostly available as an escape hatch.
 *
 * When retrieving info/fmt fields, the values stored in the buffers are typed
 * according to the actual field type. For example, the `fmt_GT` attribute
 * extracts the `GT` FMT field for a record. In the VCF specification, `GT` is
 * defined as a list of integer values. This means the bytes stored in the
 * `fmt_GT` result buffer will be integer values.
 *
 * All of the `info_*`/`fmt_*` attributes are variable-length. The offset buffer
 * combined with the datatype of the attribute allows you to interpret the
 * returned bytes appropriately (number and type of values).
 *
 * (3) Nullable attributes
 * Most attributes are non-nullable, meaning a value will be stored for the
 * attribute for every result record. The nullable attributes are:
 *
 * - "filters"
 * - "info"
 * - "info_*"
 * - "fmt"
 * - "fmt_*"
 *
 * For the nullable attributes, a validity bitmap buffer must also be provided.
 * For a result record at index `i`, the bit index `i` will be set if the value
 * of the nullable attribute has a valid (non-null) value. See the function
 * `tiledb_vcf_reader_set_validity_bitmap`.
 *
 * (4) Apache Arrow integration
 * The offsets and nullable-attribute bitmap formats adhere to the Apache Arrow
 * semantics for offsets and validity bitmaps. This is to allow zero-copy
 * conversion to Arrow Tables.
 *
 * If you are using the Arrow interface to the TileDB-VCF reader class, note
 * that your buffers must be allocated according to the Arrow requirements,
 * which are, briefly:
 * - 8-byte aligned
 * - Length-padded to a multiple of 8 bytes
 *
 * **Example**:
 *
 * Suppose you want to read attributes `pos_start` and `filters`. You would
 * provide 5 buffers:
 * - pos_start: Values buffer only
 * - filters: Values, offsets, list offsets, and validity bitmap buffers.
 *
 * Suppose the read result contained three records with the following data:
 *     pos_start  |  filters
 *   -------------+------------
 *     100        |  "f1"
 *     200        |
 *     300        |  "f2", "f3"
 *
 * The buffers would contain the following result bytes:
 *
 * pos_start values (little-endian int32 values, one per record):
 *   0x64 0x00 0x00 0x00 0xc8 0x00 0x00 0x00 0x2c 0x01 0x00 0x00
 * filters values (ASCII char values)
 *   0x66 0x31 0x66 0x32 0x66 0x33
 * filters offsets (little-endian int32 values)
 *   0x00 0x00 0x00 0x00 0x02 0x00 0x00 0x00 0x02 0x00 0x00 0x00
 *   0x04 0x00 0x00 0x00 0x06 0x00 0x00 0x00
 * filters list offsets (little-endian int32 values)
 *   0x00 0x00 0x00 0x00 0x01 0x00 0x00 0x00 0x02 0x00 0x00 0x00
 *   0x04 0x00 0x00 0x00 0x05 0x00 0x00 0x00
 * filters validity bitmap
 *   0x05
 *
 * The validity bitmap value 0x05 corresponds to binary value 0b00000101, which
 * indicates that the `filters` list for record index 0 is non-null (valid),
 * for record index 1 is null, and for record index 2 is non-null.
 *
 * @param reader VCF reader object
 * @param attribute Name of attribute
 * @param buff_size Size (in bytes) of `buff`.
 * @param buff Buffer to receive data.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_buffer_values(
    tiledb_vcf_reader_t* reader,
    const char* attribute,
    int64_t buff_size,
    void* buff);

/**
 * Sets the value offsets buffer for a variable-length attribute.
 *
 * Fixed-length attributes, such as `pos_start` or `qual`, contain a
 * single value per result record. Variable-length attributes, such as
 * `sample_name` or `info_* / fmt_*`, contain a variable number of values per
 * result record, which may be 0.
 *
 * For variable-length attributes, an extra "offsets" buffer must be provided.
 * This will be populated with the starting offset of the variable-length value
 * in the associated data buffer, for each record.
 *
 * @param reader VCF reader object
 * @param attribute Name of attribute
 * @param buff_size Size (in bytes) of `buff`.
 * @param buff Buffer to receive offsets.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_buffer_offsets(
    tiledb_vcf_reader_t* reader,
    const char* attribute,
    int64_t buff_size,
    int32_t* buff);

/**
 * Sets the list offsets buffer for a list var-len attribute. The list var-len
 * attributes are:
 * - "filters"
 * - "alleles"
 *
 * List attributes contain a multiple variable-length values per result record.
 * For example, a record that has CSV alleles `C,<NON_REF>` has 2
 * variable-length string values, `C` and `<NON_REF>`. To distinguish the
 * values, an extra "list offset" buffer must be provided.
 *
 * **Example:**
 *
 * Suppose the read results contain three records, with CSV alleles
 * `C,<NON_REF>`, `T,<NON_REF>` and `G,<NON_REF>` respectively.
 *
 * The *values* buffer would contain the chars:
 *   char:  C < N O N _ R E F > T < N O N _ R E F > G < N O N _ R E F >
 *   index: 0                   1                   2
 *          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
 *
 * The *offsets* buffer contains the positions of the individual strings ("G",
 * "<NON_REF>" etc). The offsets buffer therefore contains:
 *   [0, 1, 10, 11, 20, 21, 30]
 * e.g. the string starting at offset 11 and continuing to 19 is "<NON_REF>".
 *
 * The *list offsets* buffer contains the positions in the offsets buffer
 * associating the pairs of values with the actual records. The list offsets
 * buffer therefore contains:
 *   [0, 2, 4, 6]
 * because each record has exactly two allele strings.
 *
 * @param reader VCF reader object
 * @param attribute Name of attribute
 * @param buff_size Size (in bytes) of `buff`.
 * @param buff Buffer to receive list offsets.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_buffer_list_offsets(
    tiledb_vcf_reader_t* reader,
    const char* attribute,
    int64_t buff_size,
    int32_t* buff);

/**
 * Sets the validity bitmap buffer for a nullable attribute.
 *
 * Most attributes are non-nullable, meaning a value will be stored for the
 * attribute for every result record. The nullable attributes are:
 *
 * - "filters"
 * - "info"
 * - "info_*"
 * - "fmt"
 * - "fmt_*"
 *
 * For the nullable attributes, a validity bitmap buffer must also be provided.
 * For a result record at index `i`, the bit index `i` will be set if the value
 * of the nullable attribute has a valid (non-null) value.
 *
 * @param reader VCF reader object
 * @param attribute Name of attribute
 * @param buff_size Size (in bytes) of `buff`.
 * @param buff Buffer to receive bitmap.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_buffer_validity_bitmap(
    tiledb_vcf_reader_t* reader,
    const char* attribute,
    int64_t buff_size,
    uint8_t* buff);

/**
 * Sets a rough memory budget for the reader's internal allocations. This budget
 * is divided up equally between attribute buffers used for internal TileDB
 * queries, and the TileDB storage manager's memory budget parameters.
 *
 * The memory budget is split 50/50 between TileDB-VCF's and TileDB's internal
 * memory budget, including query buffers. For the TileDB query buffers, we
 * allocate two sets (due to double-buffering). That means the allocation size
 * of the query buffers *per attribute* is:
 *
 *   ((mem_budget / 2) / num_query_buffers) / 2.
 *
 * Example: Suppose you want to target a TileDB query buffer size of 100MB per
 * attribute. Suppose the query needs 3 fixed-len attributes and 2 var-len.
 * That is a total of 3 + 4 = 7 query buffers that need to be allocated. So:
 *
 *   required_mem_budget = 100 * 2 * 7 * 2 = 2800 MB
 *
 * The default memory budget is 2GB.
 *
 * @param reader VCF reader object
 * @param memory_mb Memory budget (in MB).
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_memory_budget(
    tiledb_vcf_reader_t* reader, int32_t memory_mb);

/**
 * Sets the max number of records that will be read until the read status is
 * considered complete.
 *
 * If instead you want to receive all records, but only process them a chunk
 * at a time, you should set your buffer sizes to be of the desired chunk size,
 * and then repeatedly resubmit the read operation until the read status is
 * complete, processing the results in between read operations.
 *
 * @param reader VCF reader object
 * @param max_num_records Max number of records
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_max_num_records(
    tiledb_vcf_reader_t* reader, int64_t max_num_records);

/**
 * Sets configuration parameters on the TileDB context used for internal
 * processing.
 *
 * The string should be of the format: "sm.option1=1000,sm.option2=baz,..."
 * with multiple TileDB config params separated by commas.
 *
 * @param reader VCF reader object
 * @param config CSV string of TileDB config param values.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_tiledb_config(
    tiledb_vcf_reader_t* reader, const char* config);

/**
 * Sets whether TileDB internal statistics should be enabled or not.
 *
 * @param reader VCF reader object
 * @param tiledb_stats_enabled whether to enable stats or not, default is false
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_tiledb_stats_enabled(
    tiledb_vcf_reader_t* reader, const bool stats_enabled);

/**
 * Gets whether TileDB internal statistics should be enabled or not.
 *
 * @param reader VCF reader object
 * @param tiledb_stats_enabled whether to enable stats or not
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_tiledb_stats_enabled(
    tiledb_vcf_reader_t* reader, bool* stats_enabled);

/**
 * Sets whether TileDB internal statistics should be enabled or not for vcf
 * header array.
 *
 * @param reader VCF reader object
 * @param tiledb_stats_enabled whether to enable stats or not, default is false
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_reader_set_tiledb_stats_enabled_vcf_header_array(
    tiledb_vcf_reader_t* reader, const bool stats_enabled);

/**
 * Gets whether TileDB internal statistics should be enabled or not for vcf
 * header array.
 *
 * @param reader VCF reader object
 * @param tiledb_stats_enabled whether to enable stats or not
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_reader_get_tiledb_stats_enabled_vcf_header_array(
    tiledb_vcf_reader_t* reader, bool* stats_enabled);

/**
 * Gets TileDB internal statistics as a string
 *
 * @param reader VCF reader object
 * @param stats a char** were the stats will be returned
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_reader_get_tiledb_stats(tiledb_vcf_reader_t* reader, char** stats);

/**
 * Gets whether a VCF reader has an AF filter set.
 *
 * @param writer VCF writer object
 * @param present a char** were the stats will be returned
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_af_filter_exists(
    tiledb_vcf_reader_t* reader, bool* present);

TILEDBVCF_EXPORT int32_t
tiledb_vcf_reader_get_samples(tiledb_vcf_reader_t* reader, const char* samples);

/**
 * Performs a blocking read operation. This reads data from the dataset into the
 * buffers that have been set on the reader.
 *
 * If all records in the dataset satisfying the query (genomic regions and
 * samples) are returned in the read operation, the read status is set to
 * 'complete'. If the buffers provided were too small to hold all records,
 * the read status is set to 'incomplete'. Simply process the partial results,
 * and resubmit the read operation until the status becomes 'complete'.
 *
 * @param reader VCF reader object
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_read(tiledb_vcf_reader_t* reader);

/**
 * Get the read status of the given reader.
 *
 * @param reader VCF reader object
 * @param status Set to the current read status
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_status(
    tiledb_vcf_reader_t* reader, tiledb_vcf_read_status_t* status);

/**
 * Get the number of records in the result of the previous read operation.
 *
 * @param reader VCF reader object
 * @param num_records Set to the number of records in the result
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_result_num_records(
    tiledb_vcf_reader_t* reader, int64_t* num_records);

/**
 * After reading some data, gets the sizes of reader results for an attribute.
 *
 * @param reader VCF reader object
 * @param attribute Name of attribute
 * @param num_offsets Set to the number of offsets in the result offsets buffer.
 * @param num_data_elements Set to the number of elements in the result values
 *      buffer. This will be the number of data elements across all cells,
 *      variable-length included.
 * @param num_data_bytes Set to the number of bytes in the result values buffer
 *      across all cells.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_result_size(
    tiledb_vcf_reader_t* reader,
    const char* attribute,
    int64_t* num_offsets,
    int64_t* num_data_elements,
    int64_t* num_data_bytes);

/**
 * Gets the number of buffers that have been set on the reader.
 *
 * @param reader VCF reader object
 * @param num_buffers Set to the number of buffers
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_num_buffers(
    tiledb_vcf_reader_t* reader, int32_t* num_buffers);

/**
 * Gets the values buffer (by index) that was set on the reader.
 *
 * @param reader VCF reader object
 * @param buffer_idx Index of buffer to get
 * @param name Set to the name of the buffer
 * @param buff Set to the data buffer.
 * @return
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_buffer_values(
    tiledb_vcf_reader_t* reader,
    int32_t buffer_idx,
    const char** name,
    void** buff);

/**
 * Gets the offsets buffer (by index) that was set on the reader.
 *
 * @param reader VCF reader object
 * @param buffer_idx Index of buffer to get
 * @param name Set to the name of the buffer
 * @param buff Set to the offsets buffer.
 * @return
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_buffer_offsets(
    tiledb_vcf_reader_t* reader,
    int32_t buffer_idx,
    const char** name,
    int32_t** buff);

/**
 * Gets the list offsets buffer (by index) that was set on the reader.
 *
 * @param reader VCF reader object
 * @param buffer_idx Index of buffer to get
 * @param name Set to the name of the buffer
 * @param buff Set to the list offsets buffer.
 * @return
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_buffer_list_offsets(
    tiledb_vcf_reader_t* reader,
    int32_t buffer_idx,
    const char** name,
    int32_t** buff);

/**
 * Gets the validity bitmap buffer (by index) that was set on the reader.
 *
 * @param reader VCF reader object
 * @param buffer_idx Index of buffer to get
 * @param name Set to the name of the buffer
 * @param buff Set to the bitmap buffer.
 * @return
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_buffer_validity_bitmap(
    tiledb_vcf_reader_t* reader,
    int32_t buffer_idx,
    const char** name,
    uint8_t** buff);

/**
 * Gets the datatype of a particular attribute.
 *
 * Returns an error if the specified attribute is unknown.
 *
 * @param reader VCF reader object
 * @param attribute Name of attribute to retrieve type of
 * @param datatype Set to the datatype of the attribute
 * @param var_len Set to `1` if the attribute is variable-length, else `0`
 * @param nullable Set to `1` if the attribute is nullable, else `0`
 * @param list Set to `1` if the attribute is a var-len list, else `0`
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_attribute_type(
    tiledb_vcf_reader_t* reader,
    const char* attribute,
    tiledb_vcf_attr_datatype_t* datatype,
    int32_t* var_len,
    int32_t* nullable,
    int32_t* list);

/**
 * Get count of queryable attributes in the array
 * @param reader VCF reader object
 * @param count int32_t which is set to count of attributes
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_queryable_attribute_count(
    tiledb_vcf_reader_t* reader, int32_t* count);

/**
 * Fetch name of a queryable attribute from the dataset
 * @param reader VCF reader object
 * @param index attribute to fetch name of
 * @param name char* returned as name
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_queryable_attribute_name(
    tiledb_vcf_reader_t* reader, int32_t index, char** name);

/**
 * Get count of materialized attributes in the array
 * @param reader VCF reader object
 * @param count int32_t which is set to count of attributes
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_materialized_attribute_count(
    tiledb_vcf_reader_t* reader, int32_t* count);

/**
 * Fetch name of a materialized attribute from the dataset
 * @param reader VCF reader object
 * @param index attribute to fetch name of
 * @param name char* returned as name
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_materialized_attribute_name(
    tiledb_vcf_reader_t* reader, int32_t index, char** name);

/**
 * Get count of fmt attributes in the array
 * @param reader VCF reader object
 * @param count int32_t which is set to count of attributes
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_fmt_attribute_count(
    tiledb_vcf_reader_t* reader, int32_t* count);

/**
 * Fetch name of a fmt attribute from the dataset
 * @param reader VCF reader object
 * @param index attribute to fetch name of
 * @param name char* returned as name
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_fmt_attribute_name(
    tiledb_vcf_reader_t* reader, int32_t index, char** name);

/**
 * Get count of info attributes in the array
 * @param reader VCF reader object
 * @param count int32_t which is set to count of attributes
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_info_attribute_count(
    tiledb_vcf_reader_t* reader, int32_t* count);

/**
 * Fetch name of an info attribute from the dataset
 * @param reader VCF reader object
 * @param index attribute to fetch name of
 * @param name char* returned as name
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_info_attribute_name(
    tiledb_vcf_reader_t* reader, int32_t index, char** name);

/**
 * Get the number of registered samples
 * @param reader VCF reader object
 * @param count number of samples registered in the dataset
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.*
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_reader_get_sample_count(tiledb_vcf_reader_t* reader, int32_t* count);

/**
 * Retrieve sample name for a given index
 * @param reader VCF reader object
 * @param index the sample name to retrieve
 * @param name char* sample name
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.*
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_sample_name(
    tiledb_vcf_reader_t* reader, int32_t index, const char** name);

/**
 * Sets verbose mode on or off
 * @param reader VCF reader object
 * @param verbose setting
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_reader_set_verbose(tiledb_vcf_reader_t* reader, bool verbose);

/**
 * Sets export to disk mode on or off
 * @param reader VCF reader object
 * @param export_to_disk setting
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_export_to_disk(
    tiledb_vcf_reader_t* reader, bool export_to_disk);

/**
 * Sets export to combined VCF mode on or off
 * @param reader VCF reader object
 * @param merge setting
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_reader_set_merge(tiledb_vcf_reader_t* reader, bool merge);

/**
 * Sets export output format
 * @param reader VCF reader object
 * @param output_format setting
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_output_format(
    tiledb_vcf_reader_t* reader, const char* output_format);

/**
 * Sets export output path
 * @param reader VCF reader object
 * @param output_path setting
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_output_path(
    tiledb_vcf_reader_t* reader, const char* output_path);

/**
 * Sets AF filter
 * @param reader VCF reader object
 * @param af_filter setting
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_af_filter(
    tiledb_vcf_reader_t* reader, const char* af_filter);

/**
 * Sets export output directory
 * @param reader VCF reader object
 * @param output_path setting
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_output_dir(
    tiledb_vcf_reader_t* reader, const char* output_dir);

/**
 * Sets verbose mode on or off
 * @param reader VCF reader object
 * @param verbose setting
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_enable_progress_estimation(
    tiledb_vcf_reader_t* reader, bool enable_progress_estimation);

/**
 * Sets the percentage of buffer size to tiledb memory budget
 * @param reader VCF reader object
 * @param buffer_percentage setting
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_buffer_percentage(
    tiledb_vcf_reader_t* reader, float buffer_percentage);

/**
 * Sets the percentage of tiledb tile cache size to overal memory budget
 * @param reader VCF reader object
 * @param buffer_percentage setting
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_tiledb_tile_cache_percentage(
    tiledb_vcf_reader_t* reader, float tile_percentage);

/**
 * Sets if the reader should validate all requested samples exist in the array
 * before running the query
 * @param reader VCF reader object
 * @param check_samples_exist setting
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_check_samples_exist(
    tiledb_vcf_reader_t* reader, bool check_samples_exist);

/**
 * Returns the version number of the TileDB VCF dataset.
 *
 * @param reader VCF reader object
 * @param version Set to the version number
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_dataset_version(
    tiledb_vcf_reader_t* reader, int32_t* version);

/**
 * Resets the reader without discarding any parameters or configuration
 * settings. This allows the same reader instance to be used for another read
 * operation, without having to reopen/reinitialize the dataset.
 *
 * @param reader VCF reader object
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_reset(tiledb_vcf_reader_t* reader);

/**
 * Resets the reader's buffers This allows the same reader instance to
 * be used for another read operation, without having to reopen/reinitialize the
 * dataset. This is used in addition to tiledb_vcf_reader_reset() if the user
 * wants to change attributes
 *
 * @param reader VCF reader object
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_reader_reset_buffers(tiledb_vcf_reader_t* reader);

/**
 * Sets if the reader print vcf regions in verbose mode
 * @param reader VCF reader object
 * @param print_vcf_regions setting
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_debug_print_vcf_regions(
    tiledb_vcf_reader_t* reader, bool print_vcf_regions);

/**
 * Sets if the reader print sample list in verbose mode
 * @param reader VCF reader object
 * @param print_sample_list setting
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_debug_print_sample_list(
    tiledb_vcf_reader_t* reader, bool print_sample_list);

/**
 * Sets if the reader print TileDB query ranges in verbose mode
 * @param reader VCF reader object
 * @param print_vcf_regions setting
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_set_debug_print_tiledb_query_ranges(
    tiledb_vcf_reader_t* reader, bool print_tiledb_query_ranges);

/**
 * Gets the last error from the reader object. Don't forget to free the error
 * object.
 *
 * @param reader VCF reader object
 * @param error Set to a newly allocated error object holding the last error.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_reader_get_last_error(
    tiledb_vcf_reader_t* reader, tiledb_vcf_error_t** error);

/* ********************************* */
/*             BED FILE              */
/* ********************************* */

/**
 * Allocate a VCF bed file object.
 *
 * @param bed_file Will be set to point at the allocated bed file object.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_bed_file_alloc(tiledb_vcf_bed_file_t** bed_file);

/**
 * Free the given VCF bed file object.
 *
 * @param bed_file Pointer to writer object to free.
 */
TILEDBVCF_EXPORT void tiledb_vcf_bed_file_free(
    tiledb_vcf_bed_file_t** bed_file);

/**
 * Gets the last error from the bed file object. Don't forget to free the error
 * object.
 *
 * @param bed_file VCF bed file object
 * @param error Set to a newly allocated error object holding the last error.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_bed_file_get_last_error(
    tiledb_vcf_bed_file_t* bed_file, tiledb_vcf_error_t** error);

/**
 * Parse a bed file into a bed file object
 * @param reader VCF reader object
 * @param bed_file VCF bed file object
 * @param bed_file_path path to bed file
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_bed_file_parse(
    tiledb_vcf_reader_t* reader,
    tiledb_vcf_bed_file_t* bed_file,
    const char* bed_file_uri);

/**
 * Get count of number of contigs in parsed bed file
 * @param bed_file
 * @param contig_count
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_bed_file_get_contig_count(
    tiledb_vcf_bed_file_t* bed_file, uint64_t* contig_count);

/**
 *
 * @param bed_file
 * @param total_region_count
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_bed_file_get_total_region_count(
    tiledb_vcf_bed_file_t* bed_file, uint64_t* total_region_count);

/**
 *
 * @param bed_file
 * @param contig_index
 * @param region_count
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_bed_file_get_contig_region_count(
    tiledb_vcf_bed_file_t* bed_file,
    uint64_t contig_index,
    uint64_t* region_count);

/**
 *
 * @param bed_file
 * @param contig_index
 * @param region_index
 * @param region_str
 * @param region_contig
 * @param region_start
 * @param region_end
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_bed_file_get_contig_region(
    tiledb_vcf_bed_file_t* bed_file,
    uint64_t contig_index,
    uint64_t region_index,
    const char** region_str,
    const char** region_contig,
    uint32_t* region_start,
    uint32_t* region_end);

/* ********************************* */
/*              WRITER               */
/* ********************************* */

/**
 * Allocate a VCF writer object.
 *
 * @param writer Will be set to point at the allocated writer object.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_alloc(tiledb_vcf_writer_t** writer);

/**
 * Free the given VCF writer object.
 *
 * @param writer Pointer to writer object to free.
 */
TILEDBVCF_EXPORT void tiledb_vcf_writer_free(tiledb_vcf_writer_t** writer);

/**
 * Initializes the writer for writing to a dataset at the given URI.
 *
 * @param writer VCF writer object
 * @param dataset_uri URI of dataset to be written to
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_writer_init(tiledb_vcf_writer_t* writer, const char* dataset_uri);

/**
 * Sets the sample files to be registered or ingested.
 *
 * @param writer VCF writer object
 * @param sample_uris CSV list of sample URIs to be registered or ingested.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_samples(
    tiledb_vcf_writer_t* writer, const char* sample_uris);

/**
 * [Creation only] Sets the info and fmt fields that should be extracted as
 * separate TileDB attributes.
 *
 * @param writer VCF writer object
 * @param attributes CSV list of fields in the format `info_*` or `fmt_*`.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_extra_attributes(
    tiledb_vcf_writer_t* writer, const char* attributes);

/**
 * [Creation only] Sets the info and fmt fields that should be extracted as
 * separate TileDB attributes using all fields in the provided VCF file.
 *
 * @param writer VCF writer object
 * @param vcf_uri VCF file used to extract the info and fmt fields.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_vcf_attributes(
    tiledb_vcf_writer_t* writer, const char* vcf_uri);

/**
 * [Creation only] Sets the checksum type to be used for the underlying arrays
 *
 * The checksum type can be set to TILEDB_VCF_CHECKSUM_MD5,
 * TILEDB_VCF_CHECKSUM_SHA256 or TILEDB_VCF_CHECKSUM_NONE to disable.
 *
 * TILEDB_VCF_CHECKSUM_SHA256 is the default
 *
 * @param writer VCF writer object
 * @param checksum_type tiledb checksum filter type to be use
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_checksum_type(
    tiledb_vcf_writer_t* writer, tiledb_vcf_checksum_type_t checksum);

/**
 * [Creation only] Sets whether duplicates are allowed in the underlying
 * array or not. By default duplicates are allowed
 *
 * @param writer VCF writer object
 * @param allow_duplicates boolean for allowing duplicates or not
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_allow_duplicates(
    tiledb_vcf_writer_t* writer, bool allow_duplicates);

/**
 * [Creation only] Set the dataset's tile capacity upon creation.
 *
 * @param writer VCF writer object
 * @param tile_capacity tile capacity for the data array
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_tile_capacity(
    tiledb_vcf_writer_t* writer, uint64_t tile_capacity);

/**
 * [Creation only] Set the length of gaps between inserted anchor records.
 *
 * @param writer VCF writer object
 * @param anchor_gap anchor gap length (in bases)
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_anchor_gap(
    tiledb_vcf_writer_t* writer, uint32_t anchor_gap);

/**
 * Creates a new TileDB-VCF dataset, using previously set parameters.
 *
 * @param writer VCF writer object
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_writer_create_dataset(tiledb_vcf_writer_t* writer);

/**
 * Registers new samples into an existing TileDB-VCF dataset, using previously
 * set parameters.
 *
 * @param writer VCF writer object
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_writer_register(tiledb_vcf_writer_t* writer);

/**
 * Ingests (stores) new samples into an existing TileDB-VCF dataset, using
 * previously set parameters.
 *
 * @param writer VCF writer object
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_store(tiledb_vcf_writer_t* writer);

/**
 * Gets the last error from the writer object. Don't forget to free the error
 * object.
 *
 * @param writer VCF writer object
 * @param error Set to a newly allocated error object holding the last error.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_get_last_error(
    tiledb_vcf_writer_t* writer, tiledb_vcf_error_t** error);

/**
 * Set number of ingestion threads
 *
 * @param writer VCF writer object
 * @param threads The number of threads used for sample ingestion.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */

TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_num_threads(
    tiledb_vcf_writer_t* writer, uint32_t threads);

/**
 * Set the total memory budget for ingestion (MiB)
 *
 * @param writer VCF writer object
 * @param total_memory_budget_mb The
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */

TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_total_memory_budget_mb(
    tiledb_vcf_writer_t* writer, uint32_t total_memory_budget_mb);

/**
 * Set the percentage of total system memory used for ingestion
 * (overrides 'total_memory_budget_mb')
 *
 * @param writer VCF writer object
 * @param total_memory_percentage The
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */

TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_total_memory_percentage(
    tiledb_vcf_writer_t* writer, float total_memory_percentage);

/**
 * Set the ratio of memory budget allocated to TileDB::sm.mem.total_budget
 *
 * @param writer VCF writer object
 * @param ratio_tiledb_memory The
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */

TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_ratio_tiledb_memory(
    tiledb_vcf_writer_t* writer, float ratio_tiledb_memory);

/**
 * Set the maximum memory allocated to TileDB::sm.mem.total_budget (MiB)
 *
 * @param writer VCF writer object
 * @param max_tiledb_memory_mb The
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */

TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_max_tiledb_memory_mb(
    tiledb_vcf_writer_t* writer, uint32_t max_tiledb_memory_mb);

/**
 * Set the size of input record buffer for each sample file (MiB)
 *
 * @param writer VCF writer object
 * @param input_record_buffer_mb The
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */

TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_input_record_buffer_mb(
    tiledb_vcf_writer_t* writer, uint32_t input_record_buffer_mb);

/**
 * Set the average VCF record size (bytes)
 *
 * @param writer VCF writer object
 * @param avg_vcf_record_size The
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */

TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_avg_vcf_record_size(
    tiledb_vcf_writer_t* writer, uint32_t avg_vcf_record_size);

/**
 * Set the ratio of worker task size to computed task size
 *
 * @param writer VCF writer object
 * @param ratio_task_size The
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */

TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_ratio_task_size(
    tiledb_vcf_writer_t* writer, float ratio_task_size);

/**
 * Set the ratio of output buffer capacity that triggers a flush to TileDB
 *
 * @param writer VCF writer object
 * @param ratio_output_flush The
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */

TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_ratio_output_flush(
    tiledb_vcf_writer_t* writer, float ratio_output_flush);

/**
 * Set max length (# columns) of an ingestion task. Affects load balancing of
 * ingestion work across threads, and total memory consumption.
 *
 * @param writer VCF writer object
 * @param size The number of threads used for sample ingestion.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */

TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_thread_task_size(
    tiledb_vcf_writer_t* writer, uint32_t size);

/**
 * Set memory budget for ingestion
 *
 * @param writer VCF writer object
 * @param size The max size of TileDB buffers before flushing. Defaults to 1GB.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */

TILEDBVCF_EXPORT int32_t
tiledb_vcf_writer_set_memory_budget(tiledb_vcf_writer_t* writer, uint64_t size);

/**
 * Set scratch space for ingestion or registration
 *
 * @param writer VCF writer object
 * @param path Directory used for local storage of downloaded remote samples
 * @param size_mb Amount of local storage that can be used for downloading
 * remote samples (MB)
 * @
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_scratch_space(
    tiledb_vcf_writer_t* writer, const char* path, uint64_t size_mb);

/**
 * Set max record buffer size
 *
 * @param writer VCF writer object
 * @param max_num_records The number of VCF records to buffer per file
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_max_num_records(
    tiledb_vcf_writer_t* writer, uint64_t max_num_records);

/**
 * Sets verbose mode on or off
 * @param reader VCF writter object
 * @param writer VCF writer object
 * @param verbose setting
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_writer_set_verbose(tiledb_vcf_writer_t* writer, bool verbose);

/**
 * Sets whether TileDB internal statistics should be enabled or not.
 *
 * @param writer VCF writer object
 * @param tiledb_stats_enabled whether to enable stats or not, default is false
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_tiledb_stats_enabled(
    tiledb_vcf_writer_t* writer, const bool stats_enabled);

/**
 * Gets whether TileDB internal statistics should be enabled or not.
 *
 * @param writer VCF writer object
 * @param tiledb_stats_enabled whether to enable stats or not
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_get_tiledb_stats_enabled(
    tiledb_vcf_writer_t* writer, bool* stats_enabled);

/**
 * Gets TileDB internal statistics as a string
 *
 * @param reader VCF  object
 * @param writer VCF writer object
 * @param stats a char** were the stats will be returned
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_writer_get_tiledb_stats(tiledb_vcf_writer_t* writer, char** stats);

/**
 * Sets whether TileDB internal statistics should be enabled or not for vcf
 * header array access.
 *
 * @param writer VCF writer object
 * @param tiledb_stats_enabled whether to enable stats or not, default is false
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_writer_set_tiledb_stats_enabled_vcf_header_array(
    tiledb_vcf_writer_t* writer, const bool stats_enabled);

/**
 * Gets whether TileDB internal statistics should be enabled or not for vcf
 * header array access.
 *
 * @param writer VCF writer object
 * @param tiledb_stats_enabled whether to enable stats or not
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_writer_get_tiledb_stats_enabled_vcf_header_array(
    tiledb_vcf_writer_t* writer, bool* stats_enabled);

/**
 * Returns the version number of the TileDB VCF dataset.
 *
 * @param writer VCF writer object
 * @param version Set to the version number
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_get_dataset_version(
    tiledb_vcf_writer_t* writer, int32_t* version);

/**
 * Sets configuration parameters on the TileDB context used for internal
 * processing.
 *
 * The string should be of the format: "sm.option1=1000,sm.option2=baz,..."
 * with multiple TileDB config params separated by commas.
 *
 * @param writer VCF reader object
 * @param config CSV string of TileDB config param values.
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_tiledb_config(
    tiledb_vcf_writer_t* reader, const char* config);

/**
 * Set sample batch size for ingestion
 *
 * @param writer VCF writer object
 * @param size number of samples to ingest per batch (default: 10)
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_sample_batch_size(
    tiledb_vcf_writer_t* writer, uint64_t size);

/**
 * Set resume partial ingestion
 *
 * @param writer  VCF writer object
 * @param resume whether to enable resumption
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_resume_sample_partial_ingestion(
    tiledb_vcf_writer_t* writer, const bool resume);

/**
 * Set contig fragment merging enabled or not
 *
 * @param writer VCF writer object
 * @param contig_fragment_merging whether to enable contig merging or not on
 * ingestion
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_contig_fragment_merging(
    tiledb_vcf_writer_t* writer, const bool contig_fragment_merging);

/**
 * Set list of contigs to force keeping separate and not allow merging. If none
 * are set, then the merging is based on only including those from
 * "set_contigs_to_allow_merging". If neither option is set, all contigs will be
 * considered for merging.
 *
 * @param writer VCF writer object
 * @param contigs array of contig strings
 * @param len length of array
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_contigs_to_keep_separate(
    tiledb_vcf_writer_t* writer, const char** contigs, const uint64_t len);

/**
 * Set list of contigs to allow merging. If none are set, then the merging is
 * based on only restricting those from "contigs_to_keep_separate". If neither
 * option is set, all contigs will be considered for merging.
 *
 * @param writer VCF writer object
 * @param contigs array of contig strings
 * @param len length of array
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_contigs_to_allow_merging(
    tiledb_vcf_writer_t* writer, const char** contigs, const uint64_t len);

/**
 * Set contig ingestion mode.
 *  0 = all contigs
 *  1 = separate contigs (chromosomes)
 *  2 = merged contigs (pseudo-contigs)
 *
 * @param writer VCF writer object
 * @param contig_mode contig ingestion mode
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_writer_set_contig_mode(tiledb_vcf_writer_t* writer, int contig_mode);

/**
 * Sets enable allele count ingestion task
 * @param writer VCF writer object
 * @param enable enable/disable
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_enable_allele_count(
    tiledb_vcf_writer_t* writer, bool enable);

/**
 * Sets enable variant stats ingestion task
 * @param writer VCF writer object
 * @param enable enable/disable
 */
TILEDBVCF_EXPORT int32_t tiledb_vcf_writer_set_enable_variant_stats(
    tiledb_vcf_writer_t* writer, bool enable);

/* ********************************* */
/*               ERROR               */
/* ********************************* */

/**
 * Gets the error message string from the error object.
 *
 * @param error VCF error object
 * @param errmsg Set to the error string
 * @return `TILEDB_VCF_OK` for success or `TILEDB_VCF_ERR` for error.
 */
TILEDBVCF_EXPORT int32_t
tiledb_vcf_error_get_message(tiledb_vcf_error_t* error, const char** errmsg);

/**
 * Free the given error object.
 *
 * @param reader Pointer to error object to free.
 */
TILEDBVCF_EXPORT void tiledb_vcf_error_free(tiledb_vcf_error_t** error);

#ifdef __cplusplus
}
#endif

#endif  // TILEDB_VCF_H
